#!/usr/bin/python
from subprocess import PIPE, Popen
from signal import alarm, signal, SIGALRM, SIGKILL
import tempfile
import shutil
import os
import logging
import sys
import re
import traceback
import socket
import uuid

class CloudRuntimeException(Exception):
    def __init__(self, errMsg):
        self.errMsg = errMsg
    def __str__(self):
        return self.errMsg
def formatExceptionInfo(maxTBlevel=5):
    cla, exc, trbk = sys.exc_info()
    excTb = traceback.format_tb(trbk, maxTBlevel)
    msg = str(exc) + "\n"
    for tb in excTb:
        msg += tb
    return msg
class bash:
    def __init__(self, args, timeout=600):
        self.args = args
        logging.debug("execute:%s"%args)
        self.timeout = timeout
        self.process = None
        self.success = False
        self.run()

    def run(self):
        class Alarm(Exception):
            pass
        def alarm_handler(signum, frame):
            raise Alarm

        try:
            self.process = Popen(self.args, shell=True, stdout=PIPE, stderr=PIPE)
            if self.timeout != -1:
                signal(SIGALRM, alarm_handler)
                alarm(self.timeout)

            try:
                self.stdout, self.stderr = self.process.communicate()
                if self.timeout != -1:
                    alarm(0)
            except Alarm:
                os.kill(self.process.pid, SIGKILL)
                raise  CloudRuntimeException("Timeout during command execution")

            self.success = self.process.returncode == 0
        except:
            raise  CloudRuntimeException(formatExceptionInfo())

        if not self.success: 
            raise  CloudRuntimeException(self.getStderr())

    def isSuccess(self):
        return self.success
    
    def getStdout(self):
        return self.stdout.strip("\n")
    
    def getLines(self):
        return self.stdout.split("\n")

    def getStderr(self):
        return self.stderr.strip("\n")



def initLoging(logFile=None):
    try:
        if logFile is None:
            logging.basicConfig(level=logging.DEBUG) 
        else: 
            logging.basicConfig(filename=logFile, level=logging.DEBUG) 
    except:
        logging.basicConfig(level=logging.DEBUG) 

class configFileOps():
    class entry():
        def __init__(self, name, value):
            self.name = name
            self.value = value
            self.state = "new"
        def setState(self, state):
            self.state = state 
        def getState(self):
            return self.state

    def __init__(self, fileName):
        self.fileName = fileName
        self.entries = []

    def addEntry(self, name, value):
        e = self.entry(name, value)
        self.entries.append(e)
        
    def getEntry(self, name):
        try:
            ctx = file(self.fileName).read(-1)
            match = re.search("^" + name + ".*", ctx, re.MULTILINE)
            if match is None:
                return ""
            line = match.group(0).split("=")
            return line[1]
        except:
            return ""

    def save(self):
        fh, abs_path = tempfile.mkstemp()
        new_file = open(abs_path, "w")

        fp = open(self.fileName, "r")

        for line  in fp.readlines():
            for entry in self.entries:
                if line.startswith(entry.name):
                    line = entry.name + "=" + entry.value + "\n"
                    entry.setState("set")
            new_file.write(line)

        for entry in self.entries:
            if entry.getState() != "set":
                new_file.write("\n" + entry.name + "=" + entry.value + "\n")

        new_file.close()
        fp.close()

        shutil.move(abs_path, self.fileName)

    def replace_line(self, startswith,stanza,always_add=False):
        lines = [ s.strip() for s in file(self.fileName).readlines() ]
        newlines = []
        replaced = False
        for line in lines:
            if line.startswith(startswith):
                newlines.append(stanza)
                replaced = True
            else: newlines.append(line)
        if not replaced and always_add: newlines.append(stanza)
        newlines = [ s + '\n' for s in newlines ]
        file(self.fileName,"w").writelines(newlines)

    def replace_or_add_line(self, startswith,stanza):
        return self.replace_line(startswith,stanza,always_add=True)

    def replace(self, lines):
        fp = file(self.fileName).read(-1) 
        sh = re.escape(lines)
        match = re.search(sh, fp, re.MULTILINE) 
        if match is not None:
            return
    
        fp += lines
        file(self.fileName, "w").write(fp)

class networkConfig():
    class devInfo():
        def __init__(self, macAddr, ipAddr, netmask, gateway, type, name):
            self.name = name
            self.macAdrr = macAddr
            self.ipAddr = ipAddr
            self.netmask = netmask
            self.gateway = gateway
            self.type = type
            self.name = name
            #dhcp or static
            self.method = None 
     
    @staticmethod
    def getDefaultNetwork():
        cmd = bash("route -n|awk \'/^0.0.0.0/ {print $2,$8}\'") 
        if not cmd.isSuccess():
            logging.debug("Failed to get default route")
            return None 

        result = cmd.getStdout().split(" ")
        gateway = result[0]
        dev = result[1]

        pdi = networkConfig.getDevInfo(dev)
        logging.debug("Found default network device:%s"%pdi.name)
        pdi.gateway = gateway
        return pdi

    @staticmethod
    def createBridge(dev, brName):
        if not networkConfig.isBridgeSupported():
            logging.debug("bridge is not supported")
            return False
        if networkConfig.isBridgeEnslavedWithDevices(brName):
            logging.debug("bridge: %s has devices enslaved"%brName)
            return False

        cmds = ""
        if not networkConfig.isBridge(brName):
            cmds = "brctl addbr %s ;"%brName
    
        cmds += "ifconfig %s up;"%brName
        cmds += "brctl addif %s %s"%(brName, dev)
        return bash(cmds).isSuccess()

    @staticmethod
    def isBridgeEnslavedWithDevices(brName):
        if not networkConfig.isBridge(brName):
            return False        

        if not os.listdir("/sys/class/net/%s/brif"%brName):
            return False           

        return True

    @staticmethod
    def isBridgeSupported():
        if os.path.exists("/proc/sys/net/bridge"):
            return True

        return bash("modprobe bridge").isSucess()

    @staticmethod
    def isNetworkDev(devName):
        return os.path.exists("/sys/class/net/%s"%devName)

    @staticmethod
    def isBridgePort(devName):
        return os.path.exists("/sys/class/net/%s/brport"%devName)
    
    @staticmethod
    def isBridge(devName):
        return os.path.exists("/sys/class/net/%s/bridge"%devName)

    @staticmethod
    def getBridge(devName):
        bridgeName = None
        if os.path.exists("/sys/class/net/%s/brport/bridge"%devName):
            realPath = os.path.realpath("/sys/class/net/%s/brport/bridge"%devName)
            bridgeName = realPath.split("/")[-1] 
        return bridgeName

    @staticmethod
    def getEnslavedDev(br, brPort):
        if not networkConfig.isBridgeEnslavedWithDevices(br):
            return None

        for dev in os.listdir("/sys/class/net/%s/brif"%br):
            br_port = int(file("/sys/class/net/%s/brif/%s/port_no"%(br,dev)).readline().strip("\n"), 16)
            if br_port == brPort:
                return dev

        return None
        
    @staticmethod
    def getDevInfo(dev):
        if not networkConfig.isNetworkDev(dev):
            logging.debug("dev: " + dev + " is not a network device")
            return None 

        netmask = None
        ipAddr = None
        macAddr = None

        cmd = bash("ifconfig " + dev)
        if not cmd.isSuccess():
            logging.debug("Failed to get address from ifconfig")
            return None

        for line in cmd.getLines():
            if line.find("HWaddr") != -1:
                macAddr = line.split("HWaddr ")[1].strip(" ")
            elif line.find("inet ") != -1:
                m = re.search("addr:(.*)\ *Bcast:(.*)\ *Mask:(.*)", line)
                if m is not None:
                    ipAddr = m.group(1).rstrip(" ")
                    netmask = m.group(3).rstrip(" ")

        if networkConfig.isBridgePort(dev):
            type = "brport"
        elif networkConfig.isBridge(dev):
            type = "bridge"
        else:
            type = "dev"

        return networkConfig.devInfo(macAddr, ipAddr, netmask, None, type, dev)

class networkConfigUbuntu(networkConfig):
    def __init__(self, syscfg):
        self.syscfg = syscfg
        self.netCfgFile = "/etc/network/interfaces"
        self.brName = None
        self.dev = None
        
    def getNetworkMethod(self, line):
        if line.find("static") != -1:
            return "static"
        elif line.find("dhcp") != -1:
            return "dhcp"
        else:
            logging.debug("Failed to find the network method from:%s"%line)
            return None

    def matchEndOfStanzas(self, line):
        if line.match("\^ *iface|\^ *mapping|\^ *auto | \^ *allow-") is not None:
            return True
        else:
            return False

    def addBridge(self, br, dev):
        fd,tmpPath = tempfile.mkstemp()
        fp = open(tmpPath, "w+")
        for line in file(self.netCfgFile).readlines():
            match = re.match("^ *iface %s.*"%dev.name, line)
            if match is not None:
                dev.method = self.getNetworkMethod(match.group(0))
                line = "\niface %s inet manual\n"%dev.name
                line += "auto %s\n"%br.name
                line += "iface %s inet %s\n"%(br.name, dev.method)
                line += "bridge_ports %s\n"%dev.name
            fp.write(line)
        fp.close()

        shutil.move(tmpPath, self.netCfgFile)

    def addDev(self, br, dev):
        logging.debug("Haven't implement yet")

    def addBridgeAndDev(self, br, dev):
        logging.debug("Haven't implement yet")

    def writeToCfgFile(self, br, dev):
        cfg = file(self.netCfgFile).read()
        ifaceDev = re.search("^ *iface %s.*"%dev.name, cfg, re.MULTILINE)
        ifaceBr = re.search("^ *iface %s.*"%br.name, cfg, re.MULTILINE)
        if ifaceDev is not None and ifaceBr is not None:
            logging.debug("%s:%s already configured"%(br.name, dev.name))
            return True
        elif ifaceDev is not None and ifaceBr is None:
            #reconfig bridge
            self.addBridge(br, dev)
        elif ifaceDev is None and ifaceBr is not None:
            #reconfig dev
            self.addDev(br, dev)
        else:
            #both need to be reconfigured
            self.addbridgeAndDev(br, dev)     
                 
    def cfgNetwork(self, dev=None, brName=None):
        if dev is None:
            device = networkConfig.getDefaultNetwork()
        else:
            device = networkConfig.getDevInfo(dev)

        if device.type == "dev":
            #Need to create a bridge on it
            if brName is None:
                brName = "cloudbr0"
            if not networkConfig.createBridge(device.name, brName):
                logging.debug("Failed to create bridge:%s on dev %s"%(brName, device.name))
                return False

            brDevice = networkConfig.getDevInfo(brName)
            self.writeToCfgFile(brDevice, device)
        elif device.type == "brport":
            brName = networkConfig.getBridge(dev)
            brDevice = networkConfig.getDevInfo(brName)
            self.writeToCfgFile(brDevice, device)
        elif device.type == "bridge":
            #Fixme, assuming the outgoing physcial device is on port 1
            enslavedDev = networkConfig.getEnslavedDev(device.name, 1)
            brDevice = device
            device = networkConfig.getDevInfo(enslavedDev)
            self.writeToCfgFile(brDevice, device)

        self.brName = brDevice.name
        self.dev = device.name
        
    def config(self):
        writeProgressBar("Configure Network...", None)
        try:
            self.cfgNetwork(self.syscfg.env.defaultNic)
        
            bash("ifup %s "%self.brName)
            bash("/etc/init.d/networking stop")
            bash("/etc/init.d/networking start")
            writeProgressBar(None, True)
        except:
            logging.debug(formatExceptionInfo())
            writeProgressBar(None, False)
            
        self.syscfg.env.nics.append(self.brName)
        self.syscfg.env.nics.append(self.brName)
        self.syscfg.env.nics.append(self.brName)
        
    def restore(self):
        pass
        
class cgroupConfigUbuntu():
    def __init__(self, syscfg):
        self.syscfg = syscfg
        
    def config(self):
        writeProgressBar("Configure cgroup...", None)

        try:
            cfo = configFileOps("/etc/cgconfig.conf")
            addConfig = "group virt {\n \
                            cpu {\n \
                                cpu.shares = 9216;\n \
                            }\n \
                        }\n"
            cfo.replace(addConfig)

            self.syscfg.stopService("cgconfig")
            self.syscfg.enableService("cgconfig",forcestart=True)

            cfo = configFileOps("/etc/cgrules.conf")
            cfgline = "root:/usr/sbin/libvirtd  cpu virt/\n"
            cfo.replace(cfgline)
        
            self.syscfg.stopService("cgred")
            self.syscfg.enableService("cgred")

            writeProgressBar(None, True)
        except:
            logging.debug(formatExceptionInfo())
            writeProgressBar(None, False)
            
    def restore(self):
        pass
            
class securityPolicyConfigUbuntu():
    def __init__(self, syscfg):
        self.syscfg = syscfg

    def config(self):
        writeProgressBar("Configure Security Policy...", None)
        result = False
        try:
            apparmor = bash("service apparmor status")
            if not apparmor.isSuccess():
                result = True
                return True

            if apparmor.getStdout() == "":
                result = True
                return True

            if bash("service apparmor stop").isSuccess():
                bash("update-rc.d -f apparmor remove")
                result = True
                return True

            return False
        except:
            logging.debug(formatExceptionInfo())
        finally:
            writeProgressBar(None, result)
            
    def restore(self):
        pass
    
class libvirtConfigUbuntu():
    def __init__(self, syscfg):
        self.syscfg = syscfg
    
    def setupLiveMigration(self):
        stanzas = (
            "listen_tcp=1",
            'tcp_port="16509"',
            'auth_tcp="none"',
            "listen_tls=0",
        )
    
        for stanza in stanzas:
            startswith = stanza.split("=")[0] + '='
            cfo = configFileOps("/etc/libvirt/libvirtd.conf")
            cfo.replace_or_add_line(startswith,stanza)
   
        if os.path.exists("/etc/init/libvirt-bin.conf"):
            cfo = configFileOps("/etc/init/libvirt-bin.conf")
            cfo.replace_line("exec /usr/sbin/libvirtd","exec /usr/sbin/libvirtd -d -l")
        else:
            cfo = configFileOps("/etc/default/libvirt-bin")
            cfo.replace_or_add_line("libvirtd_opts=","libvirtd_opts='-l -d'")
            
    def config(self):
        writeProgressBar("Configure Libvirt...", None)

        try:
            cfgline = "export CGROUP_DAEMON='cpu:/virt'"
            libvirtfile = "/etc/default/libvirt-bin"
            cfo = configFileOps(libvirtfile)
            cfo.replace(cfgline)

            self.setupLiveMigration()
            
            cfgline = "cgroup_controllers = [ \"cpu\" ]\n" \
                  "security_driver = \"none\"\n"
            filename = "/etc/libvirt/qemu.conf"
    
            cfo = configFileOps(filename)
            cfo.replace(cfgline)

            self.syscfg.stopService("libvirt-bin")
            self.syscfg.enableService("libvirt-bin")

            writeProgressBar(None, True)
        except:
            logging.debug(formatExceptionInfo())
            writeProgressBar(None, False)
            
    def restore(self):
        pass
    
class firewawllConfigUbuntu():
    def __init__(self, syscfg):
        self.syscfg = syscfg
        
    def config(self):
        writeProgressBar("Configure Firewall...", None)

        try:
            ports = "22 1798 16509".split()
            for p in ports:
                bash("ufw allow %s"%p)
            bash("ufw allow proto tcp from any to any port 5900:6100")
            bash("ufw allow proto tcp from any to any port 49152:49216")
            self.syscfg.stopService("ufw")
            self.syscfg.startService("ufw")

            writeProgressBar(None, True)
        except:
            logging.debug(formatExceptionInfo())
            writeProgressBar(None, False)
    def restore(self):
        pass
    
class cloudKitConfig():
    def __init__(self, syscfg):
        self.syscfg = syscfg
        
    def config(self):
        writeProgressBar("Configure CloudKit...", None)

        try:
            cfo = configFileOps("/etc/cloud/agent/agent.properties")  
            cfo.addEntry("host", self.syscfg.env.mgtSvr)
            cfo.addEntry("zone", self.syscfg.env.zoneToken)
            cfo.addEntry("private.network.device", self.syscfg.env.nics[0])
            cfo.addEntry("public.network.device", self.syscfg.env.nics[1])
            cfo.addEntry("guest.network.device", self.syscfg.env.nics[2])
            cfo.addEntry("guid", str(self.syscfg.env.uuid))
            cfo.save()
            
            self.syscfg.stopService("cloud-agent")
            self.syscfg.startService("cloud-agent")
            writeProgressBar(None, True)
        except:
            logging.debug(formatExceptionInfo())
            writeProgressBar(None, False)
    
    def restore(self):
        pass
    
Unknown = 0
Fedora = 1
CentOS = 2
RHEL6 = 3
RHEL5 = 4
Ubuntu = 5

class DistributionDetector():
    def __init__(self):
        self.distro = Unknown 

        if os.path.exists("/etc/fedora-release"):
            self.distro = Fedora
        elif os.path.exists("/etc/centos-release"):
            self.distro = CentOS
        elif os.path.exists("/etc/redhat-release"):
            version = file("/etc/redhat-release").readline()
            if version.find("Red Hat Enterprise Linux Server release 6") != -1:
                self.distro = RHEL6
            elif version.find("CentOS release") != -1:
                self.distro = CentOS
            else:
                self.distro = RHEL5
        elif os.path.exists("/etc/legal") and "Ubuntu" in file("/etc/legal").read(-1):
            self.distro = Ubuntu
        else: 
            self.distro = Unknown 

    def getVersion(self):
        return self.distro 
        
class sysConfig(object):
    @staticmethod
    def getSysConfigFactory(glbEnv):
        distribution = DistributionDetector().getVersion()
        if distribution == Ubuntu:
            return sysConfigUbuntu(glbEnv)
    
class sysConfigUbuntu(sysConfig):
    def __init__(self, glbEnv):
        self.env = glbEnv
        self.services = [cgroupConfigUbuntu(self),
                         securityPolicyConfigUbuntu(self),
                         networkConfigUbuntu(self),
                         libvirtConfigUbuntu(self),
                         firewawllConfigUbuntu(self),
                         cloudKitConfig(self)]
        
    def config(self):
        for service in self.services:
            service.config()

    def restore(self):
        for service in self.services:
            service.restore()
            

    def isServiceRunning(self, servicename):
        try:
            o = bash("service " + servicename + " status")
            if "start/running" in o.getStdout():
                return True
            else:
                return False
        except:
            return False

    def stopService(self, servicename,force=False):
        if self.isServiceRunning(servicename) or force:
            return bash("service " + servicename +" stop").isSuccess()

    def disableService(self, servicename):
        self.stopService(servicename)
        bash("update-rc.d -f " + servicename + " remove")

    def startService(self, servicename,force=False):
        if not self.isServiceRunning(servicename) or force:
            bash("service " + servicename + " start")

    def enableService(self, servicename,forcestart=False):
        bash("update-rc.d -f " + servicename + " remove")
        bash("update-rc.d -f " + servicename + " start 2 3 4 5 .")
        self.startService(servicename,force=forcestart)

    def isKVMEnabled(self):
        return bash("kvmok").isSuccess()
    
def getUserInputs():
    print "Welcome to CloudKit Setup:"

    cfo = configFileOps("/etc/cloud/agent/agent.properties")
    oldMgt = cfo.getEntry("host")

    mgtSvr = raw_input("What's the Management Server Name/IP:[%s]"%oldMgt)
    if mgtSvr == "":
        mgtSvr = oldMgt
    try:
        socket.getaddrinfo(mgtSvr, 443)
    except:
        print "Failed to resolve %s"%mgtSvr
        exit(1)

    oldToken = cfo.getEntry("zone")
    zoneToken = raw_input("What's the Zone Token:[%s]"%oldToken)
    
    if zoneToken == "":
        zoneToken = oldToken

    try:
        defaultNic = networkConfig.getDefaultNetwork()
        defNic = defaultNic.name
    except:
        defNic = ""
    network = raw_input("Which nic used to connect to Management Server:[%s]"%defNic)
    if network == "":
        if defNic == "":
            print "You need to specifiy one of Nic"
            exit(1)
        elif network == "":
            network = defNic

    return [mgtSvr,zoneToken, network]

def writeProgressBar(msg, result):
    if msg is not None:
        output = "%-30s"%msg
    elif result is True:
        output = "[%-2s]\n"%"OK"
    elif result is False:
        output = "[%-6s]\n"%"Failed"
    sys.stdout.write(output)
    sys.stdout.flush()

class globalEnv():
    pass

if __name__ == '__main__':
    #todo: check executing permission 
    initLoging("/var/log/cloud/setupAgent.log")

    userInputs = getUserInputs()
    glbEnv = globalEnv()
    
    glbEnv.mgtSvr = userInputs[0]
    glbEnv.zoneToken = userInputs[1]
    glbEnv.defaultNic = userInputs[2]
    glbEnv.nics = []
    #generate UUID
    glbEnv.uuid = configFileOps("/etc/cloud/agent/agent.properties").getEntry("guid")
    if glbEnv.uuid == "":
        glbEnv.uuid = uuid.uuid1()
   
    print "Starting to configure your system:"
    sysConfig = sysConfig.getSysConfigFactory(glbEnv)
    sysConfig.config()
